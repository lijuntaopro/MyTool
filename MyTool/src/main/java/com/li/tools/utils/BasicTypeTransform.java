package com.li.tools.utils;

import org.junit.Test;
/**
 * 字节转八进制字符：字节真值有负，必须转为正的int，如果直接强转，则int型的真值也是负的，与0xff，则字节的真值为正
 * 
 * 类型直接转换，其符号位不变，其装换为补码，再运算，即截取或补零。
 * 位运算，直接对整型的位作运算，即32位
 * &,为与运算。对其高位补零作运算，对应不满32为的byte和char来说，其结果是为正，但转换为byte和char就不一定是正的
 * 
 * byte与char与int的相互转换：
 * 规律之一：
 *    在byte的真值范围内(-128--127)，转换后真值相同
 * 	      超出范围：即多位直接强转少位，出现值溢出，即需要处理，如下：
 * 	  byte -128 -- +127 , -128 -- +127 , -128 -- +127
 * 	  char -384 -- -129 , -128 -- +127 , +128 -- +383
 *    int  -384 -- -129 , -128 -- +127 , +128 -- +383 
 * */
public class BasicTypeTransform {
	@Test
	/**
	 * 低转高，还是一样的真值
	 * 
	 * byte强制装换int，如-1
	 * 原码：10000001
	 * 反码：11111110
	 * 补码：11111111
	 * 补零补码：11111111 11111111 11111111 11111111(补位原则为补高位)
	 * 补零反码：11111111 11111111 11111111 11111110
	 * 补零原码：10000000 00000000 00000000 00000001
	 * 真值：-1
	 * 
	 * byte强制装换int，如127
	 * 原码：01111111
	 * 反码：01111111
	 * 补码：01111111
	 * 补零补码：00000000 00000000 00000000 01111111(补位原则为补高位)
	 * 补零反码：00000000 00000000 00000000 01111111
	 * 补零原码：00000000 00000000 00000000 01111111
	 * 真值：127
	 * 
	 * byte强制装换int，如-128
	 * 原码：不确定
	 * 反码：不确定
	 * 补码：10000000
	 * 补零补码：11111111 11111111 11111111 10000000(补位原则为补高位)
	 * 补零反码：11111111 11111111 11111111 01111111
	 * 补零原码：10000000 00000000 00000000 10000000
	 * 真值：128
	 * */
	public void byteToInt(){
		byte b = -1;
		int i = (int) b;
		System.out.println("byteToInt:"+i);
	}
	/**高转低
	 * 
	 * int强制装换byte，如-129
	 * 原码表示：10000000 00000000 00000000 10000001
	 * 反码表示：01111111 11111111 11111111 01111110
	 * 补码表示：01111111 11111111 11111111 01111111
	 * 强制转换，直接截取
	 * 截取补码：01111111(为正)
	 * 截取反码：01111111
	 * 截取原码：01111111
	 * -->真值：127
	 * 
	 * int强制装换byte，如-1
	 * 原码表示：10000000 00000000 00000000 00000001
	 * 反码表示：01111111 11111111 11111111 11111110
	 * 补码表示：01111111 11111111 11111111 11111111
	 * 强制转换，直接截取
	 * 截取补码：11111111(为负)
	 * 截取反码：11111110
	 * 截取原码：10000001
	 * -->真值：-1
	 * 
	 * int强制装换byte，如-128
	 * 原码表示：10000000 00000000 00000000 10000000
	 * 反码表示：01111111 11111111 11111111 01111111
	 * 补码表示：01111111 11111111 11111111 10000000
	 * 强制转换，直接截取
	 * 截取补码：10000000(只有-128对应，所以没有对应的反码和原码)
	 * -->真值：-128
	 * 
	 * int强制装换byte，如128
	 * 原码表示：00000000 00000000 00000000 10000000
	 * 反码表示：00000000 00000000 00000000 10000000
	 * 补码表示：00000000 00000000 00000000 10000000
	 * 强制转换，直接截取
	 * 截取补码：10000000(只有-128对应，所以没有对应的反码和原码)
	 * -->真值：-128
	 * */
	@Test
	public void intToByte(){
		int i = 129;
		byte b = (byte) i;
		System.out.println("byteToInt:"+b);
	}
	@Test
	/**位运算
	 * <<  左移位，在低位处补0
     * >>  右移位，若为正数则高位补0，若为负数则高位补1，即补最高位
     * >>> 无符号右移位，无论正负都在高位补0
	 * 
	 * 移位：有符号。-1，补最高位（32）
	 * 原码：10000000 00000000 00000000 00000001
	 * 反码：11111111 11111111 11111111 11111110
	 * 补码：11111111 11111111 11111111 11111111
	 * 移位补位补码：11111111 11111111 11111111 11111111 
	 * 移位补位反码：11111111 11111111 11111111 11111110
	 * 移位补位原码：10000000 00000000 00000000 00000001
	 * 真值：-1
	 * 
	 * 移位：符号。-1，补0（32）
	 * 原码：10000000 00000000 00000000 00000001
	 * 反码：11111111 11111111 11111111 11111110
	 * 补码：11111111 11111111 11111111 11111111
	 * 移位补位补码：00111111 11111111 11111111 11111111
	 * 移位补位反码：00111111 11111111 11111111 11111111
	 * 移位补位原码：00111111 11111111 11111111 11111111
	 * 真值：1073741823
	 * 
	 * 移位：有符号。-1，补最高位（8）
	 * 原码：10000001
	 * 反码：11100000
	 * 补码：11100001
	 * 移位补位补码：11111111 11111111 11111111 11111111
	 * 移位补位反码：11111111 11111111 11111111 11111110
	 * 移位补位原码：10000000 00000000 00000000 00000001
	 * 真值：-1
	 * 
	 * 与运算,byte：-126与0xff
	 * 
	 * byte原码：11111110 ，byte反码：10000001 byte补码：10000010
	 * 
	 * 32位补码   ：11111111 11111111 11111111 10000010 
	 * 0xff补码 ：00000000 00000000 00000000 11111111
	 * 位运算结果补码 ：00000000 00000000 00000000 10000010 
	 * 位运算结果原码 ：00000000 00000000 00000000 10000010 
	 * 真值：130
	 * */
	public void bitOperate(){
		int i = -1;
		int i2 = i >> 2;
		int i3 = i >>> 2;
		System.out.println("i2:"+i2);
		System.out.println("i3:"+i3);
		byte b = -1;
		int b2 =  (b >> 2);
		int b3 =  (b >>> 2);
		System.out.println("b2:"+b2);
		System.out.println("b3:"+b3);
		byte b4 = -126;
		byte i4 = (byte)(b4&0xff);
		System.out.println("i4:"+i4);
	}
	
}
